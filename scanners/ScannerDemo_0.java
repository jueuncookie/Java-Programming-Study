package scanners;

import java.util.Scanner;


public class ScannerDemo_0 {
    //실행하고 숫자를 입력하면 입력한 숫자의 1000배가 출력 될 것이다. 예제에서 우리가 주목해야 할 부분은 sc.nextInt()가 실행되면 자바는 사용자의 입력이 있을 때까지 변수 i에 값을 할당하지 않고 대기상태에 있게 된다. 키보드로 데이터를 입력하고 엔터를 누르면 비로서 i에 값이 담기고 i*1000을 통해서 입력값에 1000이 곱해지고 그 결과가 화면에 출력된다.
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int i = sc.nextInt();
        System.out.println(i * 1000);
        sc.close();
    }

}


// 객체 part
//<클래스와 인스턴스 그리고 객체>
//1. 메소드화 - 메소드로 만들면 코드의 양을 줄일 수 있고, 문제가 생겼을 때 원인을 더 쉽게 찾을 수 있다
//2. 유지보수를 위해 쓰기 전에 그 코드가 있는지 찾아보기(동일이름)
//*유지보수를 위해 코드 안에 연결된 것은 최대한 가까이. (연관되어 있는 것끼리 그룹핑)⇒객체 지향프로그래밍(연관된 것들 묶기)
//1. 객체화: Calculator c1= new Calculator();
//new Calculator()은 클래스 Calculator를 구체적인 제품으로 만드는 명령이다. 이렇게 만들어진 구체적인 제품을 인스턴스(instance)라고 부른다.
//- 클래스 : 설계도 /- 인스턴스 : 제품
//객체 지향의 핵심은 연관되어 있는 변수와 메소드를 하나의 그룹으로 묶어서 그룹핑하는 것이다. 연관되어 있는 부분과 반복적인 부분을 찾아 볼 수 있다.
//1) 클래스 맴버와 인스턴스 맴버
//(1) 맴버(member)는 영어로 구성원이라는 뜻이다. 객체도 구성원이 있다.
//(2) 클래스 변수
//static double PI = 3.14;
//static을 맴버(변수,메소드) 앞에 붙이면 클래스의 맴버가 된다
//클래스 변수에 접근하는 방법 두가지?
//1 인스턴스를 통해서 PI에 접근 - System.out.println(c1.PI);
//2 클래스를 통해서 PI에 접근 - System.out.println(Calculator.PI);
//=> 두번째 방법은 객체 Calculator.java의 다른 기능(sum, avg)은 필요없고, 원주율만 필요할 때 클래스에 직접 접근하기 때문에 인스턴스를 생성할 필요가 없어진다.
//클래스 변수의 용도?
//1. 인스턴스에 따라서 변하지 않는 값이 필요한 경우 (위의 예에서는 PI)
//2. 인스턴스를 생성할 필요가 없는 값을 클래스에 저장하고 싶은 경우
//3. 값의 변경 사항을 모든 인스턴스가 공유해야 하는 경우


//(3) 클래스 메소드
//메소드가 인스턴스 변수를 참조하지 않는다면 클래스 메소드를 사용해서 불필요한 인스턴스의 생성을 막을 수 있다.
//(4) 타입별비교
//- 인스턴스 메소드는 클래스 멤버에 접근 할 수 있다.
//- 클래스 메소드는 인스턴스 맴버에 접근할 수 없다.

//인스턴스 변수 -> Non-Static Field 클래스 변수 -> Static Field
